/**
 * Classification Rule Types
 *
 * Rule Engine Light für automatische Klassifikations-Vorschläge.
 * Regeln erstellen Vorschläge + Confidence, Admin entscheidet final.
 */

import { LegalBucket, FlowType } from '../ledger/types';

// =============================================================================
// MATCH TYPES
// =============================================================================

export const MATCH_TYPES = {
  CONTAINS: 'CONTAINS',
  STARTS_WITH: 'STARTS_WITH',
  ENDS_WITH: 'ENDS_WITH',
  REGEX: 'REGEX',
  EQUALS: 'EQUALS',
  AMOUNT_RANGE: 'AMOUNT_RANGE',
} as const;

export type MatchType = (typeof MATCH_TYPES)[keyof typeof MATCH_TYPES];

export const MATCH_TYPE_LABELS: Record<MatchType, string> = {
  CONTAINS: 'Enthält',
  STARTS_WITH: 'Beginnt mit',
  ENDS_WITH: 'Endet mit',
  REGEX: 'Regex-Pattern',
  EQUALS: 'Exakt gleich',
  AMOUNT_RANGE: 'Betragsbereich',
};

// =============================================================================
// SERVICE DATE RULES (Phase C)
// =============================================================================

export const SERVICE_DATE_RULES = {
  VORMONAT: 'VORMONAT',
  SAME_MONTH: 'SAME_MONTH',
  PREVIOUS_QUARTER: 'PREVIOUS_QUARTER',
} as const;

export type ServiceDateRule = (typeof SERVICE_DATE_RULES)[keyof typeof SERVICE_DATE_RULES];

export const SERVICE_DATE_RULE_LABELS: Record<ServiceDateRule, string> = {
  VORMONAT: 'Vormonat (HZV-Logik)',
  SAME_MONTH: 'Gleicher Monat',
  PREVIOUS_QUARTER: 'Vorquartal (KV-Abrechnung)',
};

export const SERVICE_DATE_RULE_DESCRIPTIONS: Record<ServiceDateRule, string> = {
  VORMONAT: 'Zahlung im Dezember → Leistung November. Typisch für HZV-Abrechnungen.',
  SAME_MONTH: 'Zahlung und Leistung im gleichen Monat. Typisch für Direktzahler.',
  PREVIOUS_QUARTER: 'Zahlung im Januar → Leistungszeitraum Q4. Typisch für KV-Quartalsabrechnungen.',
};

// =============================================================================
// MATCH FIELDS
// =============================================================================

export const MATCH_FIELDS = {
  DESCRIPTION: 'description',
  BOOKING_REFERENCE: 'bookingReference',
  BOOKING_SOURCE: 'bookingSource',
  BOOKING_SOURCE_ID: 'bookingSourceId',
  AMOUNT_CENTS: 'amountCents',
} as const;

export type MatchField = (typeof MATCH_FIELDS)[keyof typeof MATCH_FIELDS];

export const MATCH_FIELD_LABELS: Record<MatchField, string> = {
  description: 'Beschreibung',
  bookingReference: 'Buchungsreferenz',
  bookingSource: 'Buchungsquelle',
  bookingSourceId: 'Buchungsquellen-ID (z.B. IBAN)',
  amountCents: 'Betrag',
};

// =============================================================================
// CLASSIFICATION RULE TYPES
// =============================================================================

/**
 * Input for creating a new ClassificationRule
 */
export interface ClassificationRuleInput {
  name: string;
  isActive?: boolean;
  priority?: number;

  // Match-Kriterien
  matchField: MatchField;
  matchType: MatchType;
  matchValue: string;

  // Ziel-Vorschlag (mindestens eines)
  suggestedCategory?: string;
  suggestedFlowType?: FlowType;
  suggestedLegalBucket?: LegalBucket;
  confidenceBonus?: number;

  // Dimensions-Zuweisung (optional)
  assignBankAccountId?: string;
  assignCounterpartyId?: string;
  assignLocationId?: string;

  // Service-Date-Regel (optional)
  assignServiceDateRule?: ServiceDateRule;
}

/**
 * ClassificationRule as returned from API
 */
export interface ClassificationRuleResponse {
  id: string;
  caseId: string;
  name: string;
  isActive: boolean;
  priority: number;

  matchField: MatchField;
  matchType: MatchType;
  matchValue: string;

  suggestedCategory: string | null;
  suggestedFlowType: FlowType | null;
  suggestedLegalBucket: LegalBucket | null;
  confidenceBonus: number;

  // Dimensions-Zuweisung
  assignBankAccountId: string | null;
  assignCounterpartyId: string | null;
  assignLocationId: string | null;

  // Service-Date-Regel
  assignServiceDateRule: ServiceDateRule | null;

  createdAt: string;
  createdBy: string;
  updatedAt: string;
  updatedBy: string;

  // Statistik (optional, bei GET mit stats=true)
  matchCount?: number;
  lastMatchAt?: string | null;
}

// =============================================================================
// CLASSIFICATION SUGGESTION TYPES
// =============================================================================

/**
 * A suggestion generated by a classification rule
 */
export interface ClassificationSuggestion {
  ruleId: string;
  ruleName: string;
  priority: number;

  suggestedCategory?: string;
  suggestedFlowType?: FlowType;
  suggestedLegalBucket?: LegalBucket;

  // Dimensions-Zuweisung
  assignBankAccountId?: string;
  assignCounterpartyId?: string;
  assignLocationId?: string;

  // Service-Date-Vorschlag (Phase C)
  assignServiceDateRule?: ServiceDateRule;
  suggestedServiceDate?: Date;
  suggestedServicePeriodStart?: Date;
  suggestedServicePeriodEnd?: Date;

  confidence: number; // 0.0 - 1.0
  matchDetails: string; // z.B. "Beschreibung enthält 'Miete'"
}

/**
 * Result of applying classification rules to a LedgerEntry
 */
export interface ClassificationResult {
  entryId: string;
  suggestions: ClassificationSuggestion[];
  bestMatch: ClassificationSuggestion | null;
  hasConflicts: boolean; // Mehrere Regeln mit unterschiedlichen Vorschlägen
}

// =============================================================================
// RULE TEST TYPES
// =============================================================================

/**
 * Input for testing a rule against sample data
 */
export interface RuleTestInput {
  rule: ClassificationRuleInput;
  testData: {
    description: string;
    bookingReference?: string;
    bookingSource?: string;
    bookingSourceId?: string;
    amountCents: number;
  }[];
}

/**
 * Result of testing a rule
 */
export interface RuleTestResult {
  matches: number;
  total: number;
  matchedItems: {
    index: number;
    matchDetails: string;
  }[];
}
