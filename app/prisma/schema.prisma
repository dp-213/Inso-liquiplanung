// Prisma Schema for Insolvency Liquidity Planning System
// Based on SPECIFICATION.md and DATA_INGESTION_ARCHITECTURE.md

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// =============================================================================
// CORE DOMAIN ENTITIES
// =============================================================================

// InsolvencyCase - The root entity representing a single insolvency proceeding
// Each case belongs to a CustomerUser (the Insolvenzverwalter/client)
model Case {
  id          String    @id @default(uuid())
  ownerId     String    // The CustomerUser who owns this case
  caseNumber  String    @unique
  debtorName  String
  courtName   String
  openingDate DateTime?
  filingDate  DateTime
  currency    String    @default("EUR")
  status      String    @default("PRELIMINARY") // PRELIMINARY, OPENED, CLOSED
  createdAt   DateTime  @default(now())
  createdBy   String
  updatedAt   DateTime  @updatedAt
  updatedBy   String?

  // === INSOLVENCY-SPECIFIC ===
  cutoffDate           DateTime? // Stichtag: Datum des Insolvenzantrags (z.B. 29.10.2025)

  // === DEFAULT PERIOD CONFIGURATION (optional, überschreibt Plan-Defaults) ===
  defaultPeriodType    String?   // WEEKLY, MONTHLY - wenn gesetzt, wird bei neuen Plänen verwendet
  defaultPeriodCount   Int?      // Anzahl Perioden - wenn gesetzt, wird bei neuen Plänen verwendet

  owner                CustomerUser         @relation("OwnedCases", fields: [ownerId], references: [id])
  plans                LiquidityPlan[]
  ingestionJobs        IngestionJob[]
  shareLinks           ShareLink[]
  configurations       CaseConfiguration[]
  aiPreprocessingJobs  AiPreprocessingJob[]
  customerAccess       CustomerCaseAccess[] // Additional access for other customers
  bankAccounts         BankAccount[]
  counterparties       Counterparty[]       // Wichtige Gegenparteien (HAEVG, KV, etc.)
  locations            Location[]           // Standorte / Praxen
  ledgerEntries        LedgerEntry[]        // Transaction-level cash truth
  classificationRules  ClassificationRule[] // Rule Engine für Klassifikations-Vorschläge
  bankAgreements       BankAgreement[]      // Vereinbarungen mit Banken (Globalzession, etc.)
  ivNotes              IVNote[]             // IV-Kommunikation (Notizen an Insolvenzverwalter)
  casePlanning         CasePlanning?        // Strukturierte Liquiditätsplanung (JSON)
  orders               Order[]              // Bestell- und Zahlfreigaben
  companyTokens        CompanyToken[]       // Token-Zugänge für externe Firmen
  forecastScenarios    ForecastScenario[]   // Prognose-Szenarien

  @@index([ownerId])
  @@map("cases")
}

// LiquidityPlan - A liquidity plan instance belonging to a case
model LiquidityPlan {
  id            String   @id @default(uuid())
  caseId        String
  name          String
  description   String?
  planStartDate DateTime
  periodType    String   @default("WEEKLY") // WEEKLY, MONTHLY
  periodCount   Int      @default(13)       // 13 for weekly, variable for monthly
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  createdBy     String
  updatedAt     DateTime @updatedAt
  updatedBy     String?

  case        Case                   @relation(fields: [caseId], references: [id])
  versions    LiquidityPlanVersion[]
  categories  CashflowCategory[]
  assumptions PlanningAssumption[]
  insolvencyEffects InsolvencyEffect[]

  @@map("liquidity_plans")
}

// LiquidityPlanVersion - Immutable snapshot of a plan at a point in time
model LiquidityPlanVersion {
  id                  String   @id @default(uuid())
  planId              String
  versionNumber       Int
  snapshotDate        DateTime @default(now())
  snapshotReason      String
  openingBalanceCents BigInt
  dataHash            String
  createdBy           String

  plan LiquidityPlan @relation(fields: [planId], references: [id])

  @@unique([planId, versionNumber])
  @@map("liquidity_plan_versions")
}

// CashflowCategory - Categories for grouping cashflow lines
model CashflowCategory {
  id           String   @id @default(uuid())
  planId       String
  name         String
  flowType     String // INFLOW, OUTFLOW
  estateType   String // ALTMASSE, NEUMASSE
  displayOrder Int
  isSystem     Boolean  @default(false)
  createdAt    DateTime @default(now())
  createdBy    String

  plan  LiquidityPlan  @relation(fields: [planId], references: [id])
  lines CashflowLine[]

  @@unique([planId, name, flowType, estateType])
  @@map("cashflow_categories")
}

// CashflowLine - Individual line items within a category
model CashflowLine {
  id           String   @id @default(uuid())
  categoryId   String
  name         String
  description  String?
  displayOrder Int
  isLocked     Boolean  @default(false)
  createdAt    DateTime @default(now())
  createdBy    String
  updatedAt    DateTime @updatedAt
  updatedBy    String?

  category     CashflowCategory @relation(fields: [categoryId], references: [id])
  periodValues PeriodValue[]

  @@map("cashflow_lines")
}

// PeriodValue - The atomic value unit (one value for one line for one period)
// Period can be a week (WEEKLY plan) or a month (MONTHLY plan)
model PeriodValue {
  id          String   @id @default(uuid())
  lineId      String
  periodIndex Int      // 0-based index: 0-12 for weekly, 0-11 for monthly, etc.
  valueType   String   // IST, PLAN
  amountCents BigInt
  note        String?
  createdAt   DateTime @default(now())
  createdBy   String
  updatedAt   DateTime @updatedAt
  updatedBy   String?

  line CashflowLine @relation(fields: [lineId], references: [id], onDelete: Cascade)

  @@unique([lineId, periodIndex, valueType])
  @@map("period_values")
}

// =============================================================================
// INGESTION & MAPPING ENTITIES
// =============================================================================

// IngestionJob - Tracks file upload and processing pipeline
model IngestionJob {
  id                      String    @id @default(uuid())
  caseId                  String
  planId                  String?
  mappingConfigId         String?   // Which mapping config was used
  sourceType              String    // CSV_GENERIC, CSV_BANK_STATEMENT, EXCEL_LIQUIDITY, etc.
  fileName                String
  fileHashSha256          String
  fileSizeBytes           BigInt
  rawFilePath             String?
  rawFileContent          String?   // Store file content for re-run capability
  mimeType                String?
  encoding                String    @default("UTF-8")
  status                  String    @default("CREATED") // CREATED, UPLOADING, VALIDATING, PARSING, STAGING, MAPPING, VALIDATING_BUSINESS, READY, REVIEW, QUARANTINED, RESOLVED, COMMITTED, REJECTED
  errorCount              Int       @default(0)
  warningCount            Int       @default(0)
  quarantinedCount        Int       @default(0)
  recordCountRaw          Int?
  recordCountValid        Int?
  recordCountNormalized   Int?
  qualityScore            Float?    // 0-100 percentage of valid records
  startedAt               DateTime  @default(now())
  completedAt             DateTime?
  createdBy               String

  case    Case              @relation(fields: [caseId], references: [id])
  records IngestionRecord[]

  @@index([caseId])
  @@index([status])
  @@index([startedAt])
  @@map("ingestion_jobs")
}

// IngestionRecord - Individual records from parsed file
model IngestionRecord {
  id                  String   @id @default(uuid())
  jobId               String
  rowNumber           Int
  sheetName           String?  // For Excel files: which sheet this row came from
  rawData             String   // JSON stored as string - original values
  mappedData          String?  // JSON stored as string - after field mapping
  normalizedData      String?  // JSON stored as string - canonical form
  status              String   @default("STAGING") // STAGING, MAPPED, VALID, REVIEW, QUARANTINED, REJECTED, READY
  qualityTier         String?  // TIER_1_VALID, TIER_2_REVIEWABLE, TIER_3_QUARANTINED, TIER_4_REJECTED
  validationErrors    String?  // JSON stored as string
  validationWarnings  String?  // JSON stored as string

  job                 IngestionJob          @relation(fields: [jobId], references: [id], onDelete: Cascade)
  stagedEntries       StagedCashflowEntry[]
  transformations     FieldTransformation[]

  @@unique([jobId, rowNumber])
  @@index([jobId, status])
  @@map("ingestion_records")
}

// StagedCashflowEntry - Normalized form before commit to core schema
model StagedCashflowEntry {
  id                       String    @id @default(uuid())
  jobId                    String
  sourceRecordId           String
  targetCategoryName       String
  targetCategoryFlowType   String
  targetCategoryEstateType String
  lineName                 String
  lineDescription          String?
  periodIndex              Int       // 0-based period index (week or month)
  valueType                String
  amountCents              BigInt
  originalAmountRaw        String?   // Original string value before conversion
  originalDate             DateTime? // Original transaction date from import
  note                     String?
  confidenceScore          Float?
  requiresReview           Boolean   @default(false)
  reviewReason             String?
  reviewReasonCode         String?   // Machine-readable reason code
  reviewedBy               String?
  reviewedAt               DateTime?
  reviewAction             String?   // APPROVE, MODIFY, REJECT, NEEDS_CLARIFICATION
  reviewNote               String?   // Operator note when reviewing
  modifiedFields           String?   // JSON: which fields were modified during review
  status                   String    @default("STAGED") // STAGED, REVIEWED, COMMITTED, REJECTED, NEEDS_CLARIFICATION

  sourceRecord IngestionRecord @relation(fields: [sourceRecordId], references: [id], onDelete: Cascade)

  @@index([jobId, status])
  @@index([requiresReview, status])
  @@map("staged_cashflow_entries")
}

// FieldTransformation - Tracks how each field was transformed
model FieldTransformation {
  id                    String   @id @default(uuid())
  recordId              String
  sourceField           String
  sourceValue           String
  targetField           String
  targetValue           String
  transformationType    String
  transformationConfig  String? // JSON
  timestamp             DateTime @default(now())

  record IngestionRecord @relation(fields: [recordId], references: [id], onDelete: Cascade)

  @@map("field_transformations")
}

// MappingConfiguration - Defines how to map source fields to target schema
// Can be scoped to: global (projectId=null, caseId=null), per-customer, or per-case
// Note: projectId refers to CustomerUser.id (legacy naming from "Project" → "Customer" refactor)
model MappingConfiguration {
  id               String    @id @default(uuid())
  name             String
  description      String?
  sourceType       String    // CSV_GENERIC, CSV_BANK_STATEMENT, EXCEL_LIQUIDITY, etc.
  projectId        String?   // Scope: null = global template
  caseId           String?   // Scope: null = project-level or global
  version          Int       @default(1)
  isActive         Boolean   @default(false)
  fieldMappings    String    // JSON: Array of FieldMapping
  valueMappings    String    // JSON: Array of ValueMapping
  categoryMappings String    // JSON: Array of CategoryMapping
  dateFormat       String    @default("DD.MM.YYYY")
  decimalSeparator String    @default(",")
  thousandsSeparator String  @default(".")
  sheetName        String?   // For Excel: which sheet to use
  headerRow        Int       @default(1) // 1-indexed row number for headers
  createdAt        DateTime  @default(now())
  createdBy        String
  updatedAt        DateTime  @updatedAt
  updatedBy        String?

  @@index([projectId])
  @@index([caseId])
  @@index([sourceType])
  @@map("mapping_configurations")
}

// MappingTemplate - Reusable mapping templates that users can apply
model MappingTemplate {
  id               String   @id @default(uuid())
  name             String
  description      String?
  sourceType       String
  projectId        String?  // null = global template available to all
  isPublic         Boolean  @default(false) // Can be used by other projects
  fieldMappings    String   // JSON
  valueMappings    String   // JSON
  categoryMappings String   // JSON
  dateFormat       String   @default("DD.MM.YYYY")
  decimalSeparator String   @default(",")
  thousandsSeparator String @default(".")
  usageCount       Int      @default(0)
  createdAt        DateTime @default(now())
  createdBy        String
  updatedAt        DateTime @updatedAt
  updatedBy        String?

  @@index([projectId])
  @@index([sourceType])
  @@map("mapping_templates")
}

// =============================================================================
// CASE CONFIGURATION (PRESENTATION LAYER)
// =============================================================================

// CaseConfiguration - Controls presentation settings per case
model CaseConfiguration {
  id                String   @id @default(uuid())
  caseId            String
  configType        String // ROW_VISIBILITY, ROW_ORDER, GROUPING, CHART_SETTINGS
  configData        String // JSON
  createdAt         DateTime @default(now())
  createdBy         String
  updatedAt         DateTime @updatedAt
  updatedBy         String?

  case Case @relation(fields: [caseId], references: [id])

  @@unique([caseId, configType])
  @@map("case_configurations")
}

// =============================================================================
// ACCESS CONTROL
// =============================================================================

// ShareLink - Tokenized read-only links for external users
model ShareLink {
  id           String    @id @default(uuid())
  caseId       String
  token        String    @unique
  label        String // e.g., "Dr. Mueller - External Access"
  expiresAt    DateTime?
  isActive     Boolean   @default(true)
  accessCount  Int       @default(0)
  lastAccessAt DateTime?
  createdAt    DateTime  @default(now())
  createdBy    String

  case Case @relation(fields: [caseId], references: [id])

  @@map("share_links")
}

// =============================================================================
// AUDIT & LOGGING (Note: CustomerAuditLog is used for customer actions)
// =============================================================================
// Legacy AuditEvent model removed - was unused
// Customer audit logging is handled by CustomerAuditLog model below

// =============================================================================
// CUSTOMER USER MANAGEMENT (EXTERNAL INSOLVENCY ADMINISTRATORS)
// =============================================================================

// CustomerUser - Insolvenzverwalter (insolvency administrator / client)
// Each customer can own multiple cases and view them in the portal
model CustomerUser {
  id                String    @id @default(uuid())
  email             String    @unique
  passwordHash      String
  name              String
  company           String?   // Law firm or company name
  phone             String?
  logoUrl           String?   // URL to customer logo (for portal branding)
  isActive          Boolean   @default(true)
  emailVerified     Boolean   @default(false)
  lastLoginAt       DateTime?
  loginCount        Int       @default(0)
  failedLoginCount  Int       @default(0)
  lockedUntil       DateTime?
  createdAt         DateTime  @default(now())
  createdBy         String    // Admin who created the account
  updatedAt         DateTime  @updatedAt
  updatedBy         String?

  ownedCases        Case[]               @relation("OwnedCases") // Cases owned by this customer
  caseAccess        CustomerCaseAccess[] // Additional access to other customers' cases
  sessions          CustomerSession[]
  auditLogs         CustomerAuditLog[]

  @@index([email])
  @@index([isActive])
  @@map("customer_users")
}

// CustomerCaseAccess - Additional access for customers to cases they don't own
// Note: Case owners automatically have access - this is for sharing with OTHER customers
model CustomerCaseAccess {
  id              String    @id @default(uuid())
  customerId      String
  caseId          String
  accessLevel     String    @default("VIEW") // VIEW, COMMENT (future), DOWNLOAD
  grantedAt       DateTime  @default(now())
  grantedBy       String    // Admin who granted access
  expiresAt       DateTime? // Optional expiration
  isActive        Boolean   @default(true)
  revokedAt       DateTime?
  revokedBy       String?
  revokeReason    String?
  lastAccessedAt  DateTime?
  accessCount     Int       @default(0)

  customer        CustomerUser @relation(fields: [customerId], references: [id], onDelete: Cascade)
  case            Case         @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@unique([customerId, caseId])
  @@index([customerId])
  @@index([caseId])
  @@index([isActive])
  @@map("customer_case_access")
}

// CustomerSession - Active sessions for customer users
model CustomerSession {
  id            String    @id @default(uuid())
  customerId    String
  token         String    @unique
  userAgent     String?
  ipAddress     String?
  expiresAt     DateTime
  createdAt     DateTime  @default(now())
  lastActivityAt DateTime @default(now())

  customer      CustomerUser @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId])
  @@index([token])
  @@index([expiresAt])
  @@map("customer_sessions")
}

// CustomerAuditLog - Audit trail for customer actions
model CustomerAuditLog {
  id          String   @id @default(uuid())
  customerId  String
  action      String   // LOGIN, LOGOUT, VIEW_CASE, DOWNLOAD_REPORT, etc.
  caseId      String?  // Which case was accessed (if applicable)
  details     String?  // JSON - additional context
  ipAddress   String?
  userAgent   String?
  timestamp   DateTime @default(now())

  customer    CustomerUser @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId])
  @@index([caseId])
  @@index([timestamp])
  @@map("customer_audit_logs")
}

// =============================================================================
// AI-ASSISTED PREPROCESSING
// =============================================================================

// AiPreprocessingJob - Tracks an AI preprocessing session
model AiPreprocessingJob {
  id                String    @id @default(uuid())
  caseId            String
  status            String    @default("CREATED") // CREATED, PROCESSING, REVIEW, CORRECTION, APPROVED, REJECTED, COMMITTED
  totalFiles        Int       @default(0)
  processedFiles    Int       @default(0)
  iterationCount    Int       @default(0) // How many correction iterations
  lastError         String?
  createdAt         DateTime  @default(now())
  createdBy         String
  updatedAt         DateTime  @updatedAt
  completedAt       DateTime?
  approvedAt        DateTime?
  approvedBy        String?

  case Case                   @relation(fields: [caseId], references: [id])
  files AiPreprocessingFile[]
  rows  AiPreprocessingRow[]
  logs  AiPreprocessingLog[]

  @@index([caseId])
  @@index([status])
  @@index([createdAt])
  @@map("ai_preprocessing_jobs")
}

// AiPreprocessingFile - Individual files in a preprocessing job
model AiPreprocessingFile {
  id                        String   @id @default(uuid())
  jobId                     String
  fileName                  String
  fileType                  String   // CSV, EXCEL, PDF
  fileSizeBytes             BigInt
  fileHash                  String
  mimeType                  String
  rawContent                String?  // Base64 for binary, text for CSV
  status                    String   @default("PENDING") // PENDING, PROCESSING, COMPLETED, ERROR
  errorMessage              String?
  documentType              String?  // LIQUIDITAETSPLANUNG, GUV_PL, BWA, SUSA, ZAHLUNGSTERMINE, KONTOAUSZUG, GEMISCHTES_FINANZDOKUMENT, UNBEKANNT
  documentTypeExplanation   String?  // How the document type was detected
  createdAt                 DateTime @default(now())

  job  AiPreprocessingJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  rows AiPreprocessingRow[]

  @@index([jobId])
  @@map("ai_preprocessing_files")
}

// AiPreprocessingRow - Individual proposed rows from AI
model AiPreprocessingRow {
  id                    String    @id @default(uuid())
  jobId                 String
  fileId                String
  sourceLocation        String    // e.g., "Sheet1:A5" or "row:12"
  rawData               String    // JSON - original extracted values
  aiSuggestion          String    // JSON - AI's proposed structured data
  aiExplanation         String?   // Why the AI interpreted it this way
  confidenceScore       Float     // 0.0 - 1.0
  confidenceDetails     String?   // JSON - per-field confidence breakdown
  status                String    @default("PENDING") // PENDING, APPROVED, REJECTED, MODIFIED, UNCLEAR
  humanEdits            String?   // JSON - what the human changed
  reviewedBy            String?
  reviewedAt            DateTime?
  rejectionReason       String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  job  AiPreprocessingJob  @relation(fields: [jobId], references: [id], onDelete: Cascade)
  file AiPreprocessingFile @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@index([fileId])
  @@index([status])
  @@map("ai_preprocessing_rows")
}

// AiPreprocessingLog - Complete audit trail for AI preprocessing
model AiPreprocessingLog {
  id          String   @id @default(uuid())
  jobId       String
  action      String   // UPLOAD, AI_PROCESS, AI_REPROCESS, REVIEW, APPROVE, REJECT, MODIFY, COMMIT, ERROR
  details     String   // JSON - detailed information about the action
  userId      String
  timestamp   DateTime @default(now())

  job AiPreprocessingJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@index([timestamp])
  @@map("ai_preprocessing_logs")
}

// =============================================================================
// PLANNING DOCUMENTATION (no cashflows, only metadata)
// =============================================================================

// PlanningAssumption - Documentation of planning assumptions with risk assessment
// IMPORTANT: This is ONLY metadata/documentation - it does NOT create any cashflows
// Links to categories but does NOT contain amountCents
model PlanningAssumption {
  id            String   @id @default(uuid())
  planId        String
  categoryName  String   // Links to CashflowCategory name
  source        String   // e.g., "OP-Debitorenliste zum 05.01.2026"
  description   String   // Detailed description of the planning assumption
  riskLevel     String   // conservative, low, medium, high, aggressive
  createdAt     DateTime @default(now())
  createdBy     String
  updatedAt     DateTime @updatedAt
  updatedBy     String?

  plan LiquidityPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@unique([planId, categoryName])
  @@index([planId])
  @@map("planning_assumptions")
}

// InsolvencyEffect - PLAN component for insolvency-specific effects
// IMPORTANT: These are PLAN values (not IST) - clearly separated from operative cashflows
// Enables "vor/nach Insolvenzeffekten" comparison view
// Can be transferred to LedgerEntry for operative planning (idempotent via sourceEffectId)
model InsolvencyEffect {
  id            String   @id @default(uuid())
  planId        String
  name          String   // e.g., "Anfechtung SV-Beiträge", "Halteprämien"
  description   String?
  effectType    String   // INFLOW, OUTFLOW
  effectGroup   String   @default("GENERAL") // GENERAL, PROCEDURE_COST (Verfahrenskosten)
  periodIndex   Int      // 0-based period index
  amountCents   BigInt
  isActive      Boolean  @default(true)

  // NEU: Verfügbarkeits-Overlay (z.B. unechte Massekredite)
  // Bei true: Nur zur Anzeige, NICHT automatisch in Ledger überführbar
  isAvailabilityOnly  Boolean  @default(false)

  createdAt     DateTime @default(now())
  createdBy     String
  updatedAt     DateTime @updatedAt
  updatedBy     String?

  plan LiquidityPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  // NEU: Abgeleitete LedgerEntries (für idempotente Überführung)
  derivedEntries LedgerEntry[]

  @@index([planId])
  @@index([planId, periodIndex])
  @@map("insolvency_effects")
}

// BankAccount - Bankenspiegel (bank account overview)
// Shows IBAN, balances, security holders, and status - NO cashflows, only account snapshots
model BankAccount {
  id              String   @id @default(uuid())
  caseId          String
  locationId      String?  // Optional FK zu Location (null = zentrales Konto)
  bankName        String   // e.g., "Sparkasse", "Münchner Bank"
  accountName     String   // e.g., "Geschäftskonto", "Treuhandkonto"
  iban                String?  // DE11701500001009210475
  openingBalanceCents BigInt   @default(0) // Anfangssaldo vor allen Ledger-Buchungen
  securityHolder      String?  // e.g., "Globalzession Bank XY"
  isLiquidityRelevant Boolean @default(false) // true = operatives Massekonto (ISK), erscheint in Liquiditätsmatrix
  status          String   @default("available") // available, blocked, restricted
  notes           String?  // Additional notes about this account
  displayOrder    Int      @default(0)
  createdAt       DateTime @default(now())
  createdBy       String
  updatedAt       DateTime @updatedAt
  updatedBy       String?

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  location Location? @relation(fields: [locationId], references: [id])
  ledgerEntries LedgerEntry[]
  bankAgreements BankAgreement[]

  @@index([caseId])
  @@index([locationId])
  @@map("bank_accounts")
}

// BankAgreement - Vereinbarung mit Bank (Globalzession, Fortführungsbeitrag, Massekredit)
// Speichert NUR belegte Werte - keine Annahmen!
model BankAgreement {
  id                  String    @id @default(uuid())
  caseId              String
  bankAccountId       String

  // === STATUS ===
  agreementStatus     String    @default("OFFEN")  // OFFEN, VERHANDLUNG, VEREINBART
  agreementDate       DateTime?  // Datum der Vereinbarung (nur wenn VEREINBART)
  agreementNote       String?    // Freitext-Notizen zur Vereinbarung

  // === GLOBALZESSION ===
  hasGlobalAssignment Boolean   @default(false)

  // === FORTFÜHRUNGSBEITRAG (nur wenn vereinbart!) ===
  contributionRate    Decimal?  // z.B. 0.10 für 10% - NULL wenn nicht vereinbart
  contributionVatRate Decimal?  // z.B. 0.19 für 19% USt - NULL wenn nicht vereinbart

  // === MASSEKREDIT-CAP (nur wenn vertraglich festgelegt!) ===
  creditCapCents      BigInt?   // Maximaler Massekredit - NULL wenn nicht vereinbart

  // === UNSICHERHEIT EXPLIZIT MARKIEREN ===
  isUncertain         Boolean   @default(true)  // Default: offen/unsicher
  uncertaintyNote     String?   // Erklärung der Unsicherheit

  // === AUDIT (keine User-Zuordnung - wird nur von Gradify gepflegt) ===
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  case        Case        @relation(fields: [caseId], references: [id], onDelete: Cascade)
  bankAccount BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)

  @@unique([caseId, bankAccountId])
  @@index([caseId])
  @@index([bankAccountId])
  @@map("bank_agreements")
}

// Counterparty - Wichtige Gegenparteien (z.B. HAEVG, KV, große Zahler)
// Case-spezifische Stammdaten für Steuerung und Auswertung
model Counterparty {
  id            String   @id @default(uuid())
  caseId        String
  name          String   // z.B. "HAEVG", "KV Nordrhein", "PVS rhein-ruhr"
  shortName     String?  // Kurzname für Anzeige
  type          String?  // PAYER, SUPPLIER, AUTHORITY, OTHER
  matchPattern  String?  // Regex/Pattern für Auto-Matching in Beschreibungen
  isTopPayer    Boolean  @default(false)  // Separat in Auswertung ausweisen?
  notes         String?
  displayOrder  Int      @default(0)
  createdAt     DateTime @default(now())
  createdBy     String
  updatedAt     DateTime @updatedAt

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  ledgerEntries LedgerEntry[]

  @@index([caseId])
  @@map("counterparties")
}

// Location - Standorte / Praxen / Einheiten
// Case-spezifische Stammdaten für Standort-basierte Auswertung
model Location {
  id            String   @id @default(uuid())
  caseId        String
  name          String   // z.B. "Praxis Uckerath", "Standort Köln"
  shortName     String?  // Kurzname für Anzeige
  address       String?  // Optionale Adresse
  costCenter    String?  // Kostenstelle (falls relevant)
  notes         String?
  displayOrder  Int      @default(0)
  createdAt     DateTime @default(now())
  createdBy     String
  updatedAt     DateTime @updatedAt

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  bankAccounts BankAccount[]
  ledgerEntries LedgerEntry[]

  @@index([caseId])
  @@map("locations")
}

// =============================================================================
// LEDGER ENTRY - Transaction-level Cash Truth
// =============================================================================

// LedgerEntry - Single Source of Truth for all cash transactions
// Case-bound (not plan-bound) - cash truth persists across plan changes
model LedgerEntry {
  id                String   @id @default(uuid())
  caseId            String   // Case-bound, NOT plan-bound

  // === CORE ===
  transactionDate   DateTime  // Original payment date
  amountCents       BigInt    // Positive = inflow, Negative = outflow
  description       String
  note              String?

  // === VALUE TYPE ===
  valueType         String    // IST, PLAN

  // === LEGAL STATUS (lean) ===
  legalBucket       String    @default("UNKNOWN")  // MASSE, ABSONDERUNG, NEUTRAL, UNKNOWN

  // === SERVICE DATE / PERIOD (für Alt/Neu-Splitting) ===
  serviceDate         DateTime?  // Wann wurde Leistung erbracht? (einzelnes Datum)
  servicePeriodStart  DateTime?  // Beginn Leistungszeitraum (für Periodenabgrenzung)
  servicePeriodEnd    DateTime?  // Ende Leistungszeitraum (für Periodenabgrenzung)

  // === ESTATE ALLOCATION (Alt/Neu-Masse) ===
  estateAllocation    String?    // ALTMASSE, NEUMASSE, MIXED, UNKLAR
  estateRatio         Decimal?   // Bei MIXED: Anteil Neumasse (0.0-1.0) als Decimal für Präzision

  // === ALLOCATION SOURCE (Revisionssprache) ===
  allocationSource    String?    // VERTRAGSREGEL, SERVICE_DATE_RULE, PERIOD_PRORATA, VORMONAT_LOGIK, MANUELL, UNKLAR
  allocationNote      String?    // Erklärung für Audit (z.B. "Vertraglich vereinbarter Split gem. KV-Vereinbarung")

  // === SPLIT REFERENCE (für Alt/Neu-Splits) ===
  parentEntryId       String?    // Bei Split: Referenz auf Original-Buchung
  splitReason         String?    // z.B. "Alt/Neu-Split Q4/2025 gem. Vertragsregel: 1/3 - 2/3"

  // === SOURCE: IMPORT ORIGIN (audit) ===
  importSource      String?   // e.g., "OP-Liste vom 05.01.2026"
  importJobId       String?   // Reference to IngestionJob
  importFileHash    String?   // SHA-256 of source file
  importRowNumber   Int?      // Row number in source file

  // === SOURCE: BOOKING SOURCE (business) ===
  bookingSource     String?   // BANK_ACCOUNT, CASH_REGISTER, ERP, MANUAL
  bookingSourceId   String?   // e.g., IBAN (legacy, use bankAccountId instead)
  bookingReference  String?   // Invoice number, document reference

  // === STEUERUNGSDIMENSIONEN (optional, für Dashboard/Auswertung) ===
  bankAccountId     String?   // Referenz auf Bankenspiegel
  counterpartyId    String?   // Referenz auf Gegenpartei (z.B. HAEVG, KV)
  locationId        String?   // Referenz auf Standort/Praxis
  steeringTag       String?   // Freies Tag (z.B. TOP_PAYER, SYSTEMRELEVANT)
  categoryTag       String?   // Geschäftskategorie für Matrix-Zuordnung (z.B. HZV, KV, ALTFORDERUNG_KV, PERSONAL)
  categoryTagSource String?   // IMPORT, AUTO, MANUELL -- WIE wurde der Tag gesetzt?
  categoryTagNote   String?   // Entscheidungsnotiz (z.B. "Übernommen: HZV (COUNTERPARTY_PATTERN)")

  // === CATEGORY TAG VORSCHLÄGE (Engine-Vorschlag, flüchtig) ===
  suggestedCategoryTag        String?   // Vorgeschlagener Matrix-Tag (z.B. "HZV")
  suggestedCategoryTagReason  String?   // Engine-Begründung: "HZV (COUNTERPARTY_PATTERN)"

  // === GOVERNANCE (Review-Status) ===
  reviewStatus      String    @default("UNREVIEWED")  // UNREVIEWED, CONFIRMED, ADJUSTED
  reviewedBy        String?
  reviewedAt        DateTime?
  reviewNote        String?

  // === GOVERNANCE (Änderungs-Tracking bei ADJUSTED) ===
  changeReason      String?   // Pflicht bei ADJUSTED
  previousAmountCents BigInt? // Ursprünglicher Betrag vor Korrektur

  // === KLASSIFIKATIONS-VORSCHLÄGE (von Rule Engine) ===
  suggestedLegalBucket    String?   // MASSE, ABSONDERUNG, NEUTRAL - Vorschlag
  suggestedCategory       String?   // Optional: Kategorie-Name Vorschlag
  suggestedConfidence     Float?    // 0.0 - 1.0 Confidence-Score
  suggestedRuleId         String?   // Welche ClassificationRule hat gematcht
  suggestedReason         String?   // Erklärungstext für den Vorschlag

  // === DIMENSIONS-VORSCHLÄGE (von Rule Engine) ===
  suggestedBankAccountId  String?   // Vorgeschlagenes Bankkonto
  suggestedCounterpartyId String?   // Vorgeschlagene Gegenpartei
  suggestedLocationId     String?   // Vorgeschlagener Standort

  // === SERVICE-DATE-VORSCHLÄGE (von Rule Engine, Phase C) ===
  suggestedServiceDate      DateTime? // Vorgeschlagenes Leistungsdatum
  suggestedServicePeriodStart DateTime? // Vorgeschlagener Leistungszeitraum Start
  suggestedServicePeriodEnd   DateTime? // Vorgeschlagener Leistungszeitraum Ende
  suggestedServiceDateRule    String?   // Welche Regel wurde angewandt (VORMONAT, etc.)

  // === LINEAGE: InsolvencyEffect-Herkunft ===
  // Wenn dieser Entry aus einem InsolvencyEffect abgeleitet wurde
  // Ermöglicht idempotente Überführung (Effekt-Änderung → DELETE + CREATE)
  sourceEffectId    String?

  // === TRANSFER PAIRING (Umbuchungen zwischen Bankkonten) ===
  transferPartnerEntryId  String?   // Gegenbuchung bei interner Umbuchung (symmetrisch)

  // === AUDIT ===
  createdAt         DateTime  @default(now())
  createdBy         String
  updatedAt         DateTime  @updatedAt

  // === RELATIONS ===
  case              Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  bankAccount       BankAccount? @relation(fields: [bankAccountId], references: [id])
  counterparty      Counterparty? @relation(fields: [counterpartyId], references: [id])
  location          Location? @relation(fields: [locationId], references: [id])
  sourceEffect      InsolvencyEffect? @relation(fields: [sourceEffectId], references: [id], onDelete: SetNull)
  order             Order?            // Rückrelation: Wurde aus einer Freigabe erstellt?
  auditLogs         LedgerAuditLog[]

  // Self-referential relation für Split-Tracking
  parentEntry       LedgerEntry?  @relation("SplitEntries", fields: [parentEntryId], references: [id], onDelete: SetNull)
  splitChildren     LedgerEntry[] @relation("SplitEntries")

  @@index([caseId])
  @@index([caseId, transactionDate])
  @@index([caseId, valueType])
  @@index([caseId, reviewStatus])
  @@index([caseId, reviewStatus, suggestedLegalBucket])
  @@index([caseId, bankAccountId])
  @@index([caseId, counterpartyId])
  @@index([caseId, locationId])
  @@index([importJobId])
  @@index([sourceEffectId])
  @@index([parentEntryId])
  @@index([estateAllocation])
  @@index([transferPartnerEntryId])
  @@map("ledger_entries")
}

// =============================================================================
// LEDGER AUDIT LOG - Vollständiges Audit-Trail für alle Ledger-Änderungen
// =============================================================================

model LedgerAuditLog {
  id            String   @id @default(uuid())
  ledgerEntryId String
  caseId        String
  action        String   // CREATED, UPDATED, CONFIRMED, ADJUSTED, DELETED
  fieldChanges  String   // JSON: {field: {old, new}}
  reason        String?
  userId        String
  timestamp     DateTime @default(now())

  ledgerEntry   LedgerEntry @relation(fields: [ledgerEntryId], references: [id], onDelete: Cascade)

  @@index([ledgerEntryId])
  @@index([caseId, timestamp])
  @@map("ledger_audit_logs")
}

// =============================================================================
// AGGREGATION CACHE - Tracking für PeriodValue-Aggregation
// =============================================================================

model AggregationCache {
  id                      String    @id @default(uuid())
  caseId                  String    @unique
  planId                  String
  status                  String    @default("CURRENT") // CURRENT, STALE, REBUILDING
  lastAggregatedAt        DateTime
  dataHashAtAggregation   String    // Hash der Ledger-Daten zum Zeitpunkt der Aggregation
  pendingChanges          Int       @default(0)
  lastChangeAt            DateTime?

  @@index([caseId])
  @@map("aggregation_cache")
}

// =============================================================================
// IV NOTES - Kommunikation mit Insolvenzverwalter
// =============================================================================

// IVNote - Notizen/Aufgaben für Kommunikation mit IV
model IVNote {
  id          String   @id @default(uuid())
  caseId      String
  content     String
  status      String   @default("OFFEN")      // OFFEN, WARTET, ERLEDIGT
  priority    String   @default("MITTEL")     // NIEDRIG, MITTEL, HOCH, KRITISCH
  author      String   @default("Sonja Prinz") // Hardcoded - Sonja ist Haupt-Interface zu IV
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@index([caseId, status])
  @@map("iv_notes")
}

// =============================================================================
// CLASSIFICATION RULES - Rule Engine Light für Vorschläge
// =============================================================================
// ARCHITEKTUR: Regeln arbeiten NUR auf ImportContext.normalized, NIE auf LedgerEntry!
// matchField referenziert normalized Keys: bezeichnung, standort, counterpartyHint, arzt, etc.
// Siehe: /lib/import/normalized-schema.ts für vollständige Liste

model ClassificationRule {
  id              String   @id @default(uuid())
  caseId          String
  name            String
  isActive        Boolean  @default(true)
  priority        Int      @default(100)  // Niedrigere Zahl = höhere Priorität

  // Match-Kriterien (auf ImportContext.normalized)
  matchField      String   // NORMALIZED FIELDS: bezeichnung, standort, counterpartyHint, arzt, kategorie, etc.
  matchType       String   // CONTAINS, STARTS_WITH, ENDS_WITH, REGEX, EQUALS, AMOUNT_RANGE
  matchValue      String   // Der Suchwert oder Regex-Pattern

  // Ziel-Vorschlag (eines oder mehrere)
  suggestedCategory     String?   // Vorgeschlagene CashflowCategory
  suggestedFlowType     String?   // INFLOW, OUTFLOW
  suggestedLegalBucket  String?   // MASSE, ABSONDERUNG, NEUTRAL
  confidenceBonus       Float     @default(0.0)  // Zusätzlicher Confidence-Score

  // Dimensions-Zuweisung (NEU)
  assignBankAccountId   String?   // Direkte Zuweisung Bankkonto
  assignCounterpartyId  String?   // Direkte Zuweisung Gegenpartei
  assignLocationId      String?   // Direkte Zuweisung Standort

  // Service-Date-Regel (für Alt/Neu-Zuordnung)
  // VORMONAT: Zahlung bezieht sich auf Vormonat (HZV: Dezember-Zahlung → November)
  // SAME_MONTH: Zahlung = Leistungsmonat (Direktzahler)
  // PREVIOUS_QUARTER: KV-Quartalsabrechnung (Q4/25-Zahlung im Jan → Okt-Dez)
  assignServiceDateRule String?   // VORMONAT, SAME_MONTH, PREVIOUS_QUARTER

  createdAt       DateTime @default(now())
  createdBy       String
  updatedAt       DateTime @updatedAt
  updatedBy       String?

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId, isActive])
  @@map("classification_rules")
}

// =============================================================================
// CASE PLANNING - Strukturierte Liquiditätsplanung
// =============================================================================

// CasePlanning - Komplette Planungsstruktur als JSON-Blob
// Enthält: Monate, Annahmen, Offene Fragen, Zusammenfassung, IV-Abweichungen
model CasePlanning {
  id            String   @id @default(uuid())
  caseId        String   @unique
  planningData  String   // JSON: komplette Planungsstruktur
  version       String   // z.B. "Korrigiert 08.02.2026"
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@map("case_planning")
}

// =============================================================================
// ORDER MODULE - Bestell- und Zahlfreigabe
// =============================================================================

// Order - Eingereichte Bestell-/Zahlungsanfragen zur Freigabe durch IV
model Order {
  id              String   @id @default(uuid())
  caseId          String

  // Typ-Unterscheidung
  type            String   @default("ZAHLUNG")  // BESTELLUNG | ZAHLUNG

  // Eingabedaten
  requestDate     DateTime @default(now())
  invoiceDate     DateTime // Bei ZAHLUNG: Rechnungsdatum, bei BESTELLUNG: erwartetes Zahlungsdatum
  amountCents     BigInt
  creditor        String   // Name des Gläubigers/Lieferanten
  description     String
  notes           String?  // Ergänzende Informationen (z.B. Kontext, Dringlichkeit)

  // Dokument-Upload (Base64-gespeichert)
  documentName      String?  // Originaler Dateiname
  documentMimeType  String?  // z.B. "application/pdf"
  documentSizeBytes BigInt?  // Dateigröße in Bytes
  documentContent   String?  // Base64-encoded Dateiinhalt

  // Status
  status          String   @default("PENDING") // PENDING, APPROVED, REJECTED

  // IV kann abweichenden Betrag genehmigen
  approvedAmountCents BigInt?

  // Approval/Rejection Info
  approvedAt      DateTime?
  approvedBy      String?  // UserId
  rejectedAt      DateTime? // Separates Feld für Ablehnungszeitpunkt
  rejectionReason String?

  // Integration mit LedgerEntry
  ledgerEntryId   String?  @unique
  ledgerEntry     LedgerEntry? @relation(fields: [ledgerEntryId], references: [id], onDelete: SetNull)

  case            Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)

  createdAt       DateTime @default(now())

  @@index([caseId])
  @@index([caseId, status])
  @@map("orders")
}

// CompanyToken - Token-basierter Zugang für externe Firmen (Buchhaltung, Lieferanten)
model CompanyToken {
  id          String   @id @default(uuid())
  caseId      String
  token       String   @unique // Zufälliger Access Token für URL
  label       String   // z.B. "Buchhaltung Müller GmbH"
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  case        Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@map("company_tokens")
}

// =============================================================================
// FORECAST MODULE - Vorwärtsgerichtete Liquiditätsprognose
// =============================================================================

// ForecastScenario - Ein Prognose-Szenario (MVP: nur BASE)
model ForecastScenario {
  id                      String    @id @default(uuid())
  caseId                  String
  name                    String
  description             String?
  scenarioType            String    @default("BASE")  // BASE, DOWNSIDE, UPSIDE, CUSTOM
  isActive                Boolean   @default(true)
  isLocked                Boolean   @default(false)
  lockedAt                DateTime?
  lockedBy                String?
  lockedReason            String?
  periodType              String    // WEEKLY, MONTHLY
  periodCount             Int
  planStartDate           DateTime
  istCutoffOverride       Int?      // Manueller Override; null = automatisch aus Matrix
  openingBalanceCents     BigInt    // IST-Closing der letzten IST-Periode
  openingBalanceSource    String
  reservesTotalCents      BigInt    @default(0)
  createdAt               DateTime  @default(now())
  createdBy               String    @default("admin")
  updatedAt               DateTime  @updatedAt

  case        Case                  @relation(fields: [caseId], references: [id], onDelete: Cascade)
  assumptions ForecastAssumption[]

  @@index([caseId])
  @@map("forecast_scenarios")
}

// ForecastAssumption - Einzelne Annahme innerhalb eines Szenarios
model ForecastAssumption {
  id                    String    @id @default(uuid())
  scenarioId            String
  caseId                String
  categoryKey           String    // z.B. "HZV_UCKERATH", "PERSONAL"
  categoryLabel         String    // z.B. "HZV Uckerath"
  flowType              String    // INFLOW, OUTFLOW
  assumptionType        String    // RUN_RATE, FIXED, ONE_TIME, PERCENTAGE_OF_REVENUE
  baseAmountCents       BigInt
  baseAmountSource      String    // Pflicht: Quellenangabe
  baseAmountNote        String?
  growthFactorPercent   Decimal?  // z.B. -5.0 = 5% Rückgang pro Periode
  seasonalProfile       String?   // JSON: [1.0, 1.0, 1.3, ...] (12 Monatsfaktoren)
  startPeriodIndex      Int
  endPeriodIndex        Int
  isActive              Boolean   @default(true)
  sortOrder             Int       @default(0)
  createdAt             DateTime  @default(now())
  createdBy             String    @default("admin")
  updatedAt             DateTime  @updatedAt

  scenario  ForecastScenario @relation(fields: [scenarioId], references: [id], onDelete: Cascade)

  @@index([scenarioId])
  @@index([caseId, categoryKey])
  @@map("forecast_assumptions")
}
